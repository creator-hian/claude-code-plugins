# Pattern Library (POCU)

Complete examples for all common XML documentation scenarios following POCU coding standards.

## 1. Simple Properties and Fields

### Recommended Pattern
```csharp
/// <summary>
/// Indicates whether the action executed successfully
/// </summary>
public bool Success { get; set; }

/// <summary>
/// Number of retry attempts
/// </summary>
public int RetryCount { get; set; }

/// <summary>
/// Priority level of the action
/// </summary>
public int Priority { get; set; }
```

### Korean Example
```csharp
/// <summary>
/// 액션 실행 성공 여부
/// </summary>
public bool Success { get; set; }

/// <summary>
/// 재시도 횟수
/// </summary>
public int RetryCount { get; set; }

/// <summary>
/// 액션 우선순위
/// </summary>
public int Priority { get; set; }
```

**Rationale**: Simple properties are self-explanatory. Use clear, concise language.

---

## 2. Complex Concepts (Use `<remarks>`)

### Recommended Pattern
```csharp
/// <summary>
/// Indicates whether the action was skipped
/// </summary>
/// <remarks>
/// Set to true when skipped due to unmet conditions.
/// If true, the action was not executed regardless of Success value.
/// </remarks>
public bool Skipped { get; set; }

/// <summary>
/// Additional data generated by action execution
/// </summary>
/// <remarks>
/// Context information that can be utilized by other actions or systems.
/// </remarks>
public Dictionary<string, object> OutputData { get; set; }
```

### Korean Example
```csharp
/// <summary>
/// 액션이 건너뛰어졌는지 여부
/// </summary>
/// <remarks>
/// 조건이 충족되지 않아 건너뛴 경우 true로 설정됩니다.
/// true인 경우, Success 값과 관계없이 액션이 실행되지 않았음을 의미합니다.
/// </remarks>
public bool Skipped { get; set; }
```

---

## 3. Classes and Structs

### Recommended Pattern (POCU)
```csharp
/// <summary>
/// Individual action execution result
/// </summary>
/// <remarks>
/// Contains detailed result information after a single EventAction is executed.
/// Included in the ActionResults list of EventActionResult.
/// </remarks>
[Serializable]
public class ActionResult
{
    private readonly Dictionary<string, object> mOutputData;
    private bool mbIsProcessed;

    // Implementation...
}

/// <summary>
/// Type-safe identifier representing event type
/// </summary>
/// <remarks>
/// Prevents string-based errors in event type identification and provides
/// compile-time type safety for event routing.
/// </remarks>
public readonly struct SEventType
{
    public int Value { get; private init; }
}
```

**Rationale**: Classes use `mPascalCase` for private fields, `mbPascalCase` for booleans. Structs use `S` prefix.

---

## 4. Methods

### Simple Methods (POCU)
```csharp
public class ActionResult
{
    private Dictionary<string, object> mOutputData;

    /// <summary>
    /// Sets output data
    /// </summary>
    public void SetOutputData(string key, object value)
    {
        Debug.Assert(key != null);

        if (mOutputData == null)
        {
            mOutputData = new Dictionary<string, object>();
        }
        mOutputData[key] = value;
    }

    /// <summary>
    /// Checks whether action was actually executed
    /// </summary>
    public bool WasExecuted()
    {
        return !Skipped;
    }
}
```

### Complex Methods with Parameters (POCU)
```csharp
public class DataService
{
    private readonly Dictionary<string, object> mOutputData;

    /// <summary>
    /// Retrieves output data
    /// </summary>
    /// <typeparam name="T">Data type to return</typeparam>
    /// <param name="key">Key to retrieve</param>
    /// <param name="defaultValue">Default value to return if key is not found</param>
    /// <returns>Retrieved data or default value</returns>
    public T GetOutputData<T>(string key, T defaultValue = default(T))
    {
        Debug.Assert(key != null);

        object value;
        if (mOutputData == null || !mOutputData.TryGetValue(key, out value))
        {
            return defaultValue;
        }

        return convertValue<T>(value, defaultValue);
    }

    private T convertValue<T>(object value, T defaultValue)
    {
        try
        {
            if (value is T directValue)
            {
                return directValue;
            }

            return (T)Convert.ChangeType(value, typeof(T));
        }
        catch
        {
            return defaultValue;
        }
    }
}
```

### Multi-Step Processes (Use `<br/>`)
```csharp
public class EventExecutor
{
    private readonly IEventRepository mRepository;

    /// <summary>
    /// Executes event
    /// </summary>
    /// <param name="systemId">System ID</param>
    /// <param name="eventId">Event ID</param>
    /// <param name="contextDataOrNull">Context data</param>
    /// <returns>Event execution result</returns>
    /// <remarks>
    /// <para>
    /// <strong>Execution Process:</strong><br/>
    /// 1. Event definition lookup<br/>
    /// 2. Event-level condition evaluation (performance optimization)<br/>
    /// 3. Direct action list processing<br/>
    /// 4. Execution time and metadata configuration
    /// </para>
    /// </remarks>
    public async UniTask<EventActionResult> ExecuteEvent(
        string systemId,
        string eventId,
        object contextDataOrNull = null)
    {
        Debug.Assert(systemId != null);
        Debug.Assert(eventId != null);

        // Implementation...
    }
}
```

### Feature Lists (Use `<br/>`)
```csharp
/// <summary>
/// Action execution engine
/// </summary>
/// <remarks>
/// <para>
/// <strong>Key Features:</strong><br/>
/// - Thread-safe action handler management<br/>
/// - Event definition caching and updates<br/>
/// - Condition-based action filtering<br/>
/// - Performance measurement and result aggregation
/// </para>
/// </remarks>
public class ActionExecutionEngine
{
    private readonly Dictionary<string, IActionHandler> mHandlers;
    private readonly object mLock;

    // Implementation...
}
```

---

## 5. Factory Methods (POCU)

### Recommended Pattern
```csharp
public class ActionResult
{
    /// <summary>
    /// Creates success result
    /// </summary>
    public static ActionResult CreateSuccess(
        string actionType,
        string messageOrNull = null,
        TimeSpan executionTime = default,
        Dictionary<string, object> outputDataOrNull = null)
    {
        Debug.Assert(actionType != null);

        string message;
        if (messageOrNull != null)
        {
            message = messageOrNull;
        }
        else
        {
            message = $"{actionType} action completed successfully.";
        }

        ActionResult result = new ActionResult(true, message, actionType, executionTime);
        if (outputDataOrNull != null)
        {
            result.OutputData = outputDataOrNull;
        }
        return result;
    }

    /// <summary>
    /// Creates failure result
    /// </summary>
    public static ActionResult CreateFailure(
        string actionType,
        string message,
        Exception exceptionOrNull = null,
        TimeSpan executionTime = default)
    {
        Debug.Assert(actionType != null);
        Debug.Assert(message != null);

        ActionResult result = new ActionResult(false, message, actionType, executionTime);

        if (exceptionOrNull != null)
        {
            result.ExceptionType = exceptionOrNull.GetType().Name;
            result.StackTrace = exceptionOrNull.StackTrace;
        }

        return result;
    }

    /// <summary>
    /// Creates skipped result
    /// </summary>
    /// <remarks>
    /// Skipping is not considered an error, so Success is set to true.
    /// </remarks>
    public static ActionResult CreateSkipped(string actionType, string reason)
    {
        Debug.Assert(actionType != null);
        Debug.Assert(reason != null);

        return new ActionResult
        {
            Success = true,  // Skipping is not an error
            Skipped = true,
            ActionType = actionType,
            Message = $"{actionType} action skipped: {reason}",
            SkipReason = reason,
            ProcessedAt = DateTime.UtcNow,
        };
    }
}
```

**Rationale**: Factory method names are self-documenting. Add remarks for special behaviors. Use OrNull suffix for nullable parameters.

---

## 6. Constructors (POCU)

### Recommended Pattern
```csharp
public class ActionResult
{
    private Dictionary<string, object> mOutputData;
    private string mExceptionType;
    private string mStackTrace;

    /// <summary>
    /// Default constructor
    /// </summary>
    public ActionResult()
    {
        initializeDefaults();
    }

    /// <summary>
    /// Parameterized constructor
    /// </summary>
    /// <param name="success">Success status</param>
    /// <param name="message">Result message</param>
    /// <param name="actionType">Action type</param>
    /// <param name="executionTime">Execution time</param>
    public ActionResult(
        bool success,
        string message,
        string actionType,
        TimeSpan executionTime = default)
    {
        Debug.Assert(message != null);
        Debug.Assert(actionType != null);

        Success = success;
        Message = message;
        ActionType = actionType;
        ExecutionTime = executionTime;
        initializeDefaults();
    }

    private void initializeDefaults()
    {
        mOutputData = new Dictionary<string, object>();
        mExceptionType = string.Empty;
        mStackTrace = string.Empty;
    }
}
```

**Rationale**: Constructor parameters are typically self-explanatory from names and types. Use camelCase for private methods.

---

## 7. Exception Documentation

### Recommended Pattern
```csharp
public class VRMLoader
{
    private bool mbIsReady;

    /// <summary>
    /// Loads VRM model from specified path
    /// </summary>
    /// <param name="path">Addressable path to VRM asset</param>
    /// <returns>Loaded VRM instance</returns>
    /// <exception cref="ArgumentNullException">Thrown when path is null</exception>
    /// <exception cref="InvalidOperationException">Thrown when VRM context is not ready</exception>
    /// <exception cref="System.IO.FileNotFoundException">Thrown when VRM asset is not found</exception>
    public async UniTask<VrmInstance> LoadVRM(string path)
    {
        if (path == null)
        {
            throw new ArgumentNullException(nameof(path));
        }

        if (!mbIsReady)
        {
            throw new InvalidOperationException("VRM context is not ready");
        }

        // Implementation...
    }
}
```

**Rationale**: Document exceptions that are part of the method's contract. No Async suffix per POCU.

---

## 8. Property with Side Effects

### Use `<value>` Tag (POCU)
```csharp
public class AnimationController
{
    private IAnimationSystem mCurrentSystem;

    /// <summary>
    /// Current animation mode
    /// </summary>
    /// <value>
    /// Gets or sets the animation mode. Setting this value automatically switches
    /// the underlying animation system. Returns null if no system is active.
    /// </value>
    public EAnimationMode? CurrentMode
    {
        get
        {
            if (mCurrentSystem != null)
            {
                return mCurrentSystem.Mode;
            }
            return null;
        }
        set
        {
            if (value.HasValue)
            {
                activateAnimationSystem(value.Value).Forget();
            }
        }
    }

    private async UniTask activateAnimationSystem(EAnimationMode mode)
    {
        // Implementation...
    }
}
```

### Simple Properties (No `<value>` needed)
```csharp
/// <summary>
/// Indicates whether the VRM model is loaded
/// </summary>
public bool IsModelLoaded { get; private set; }

/// <summary>
/// Number of available animations
/// </summary>
public int AnimationCount => mAnimations?.Count ?? 0;
```

**Rationale**: Use `<value>` only when getter/setter have side effects or non-obvious behavior.

---

## 9. Enums (POCU)

### Recommended Pattern
```csharp
/// <summary>
/// Animation system mode
/// </summary>
public enum EAnimationMode
{
    /// <summary>
    /// VRM Animation using VRMA files via UniVRM
    /// </summary>
    VRMAnimation,

    /// <summary>
    /// Unity Animator Controller using Mecanim
    /// </summary>
    AnimatorController,

    /// <summary>
    /// Hybrid mode supporting runtime switching between VRM and Animator
    /// </summary>
    Hybrid
}
```

### Bit Flags
```csharp
/// <summary>
/// Action execution options
/// </summary>
[Flags]
public enum EActionFlags
{
    /// <summary>No special options</summary>
    None = 0,

    /// <summary>Skip condition evaluation</summary>
    SkipConditions = 1 << 0,

    /// <summary>Continue execution even if action fails</summary>
    ContinueOnFailure = 1 << 1,

    /// <summary>Log detailed execution information</summary>
    VerboseLogging = 1 << 2
}
```

**Rationale**: Enums use `E` prefix per POCU. Each enum value should have clear `<summary>` describing its purpose.

---

## 10. Extension Methods (POCU)

### Recommended Pattern
```csharp
/// <summary>
/// VRMController extension methods for animation configuration
/// </summary>
public static class VRMAnimationExtensions
{
    /// <summary>
    /// Activates animation system using ConfigAsset
    /// </summary>
    /// <param name="controller">VRMController instance</param>
    /// <param name="configAsset">Configuration asset to apply</param>
    /// <returns>
    /// true: Activation succeeded<br/>
    /// false: Activation failed
    /// </returns>
    public static async UniTask<bool> ActivateWithConfigAsset(
        this VRMController controller,
        VRMAnimationConfigAsset configAsset)
    {
        Debug.Assert(controller != null);
        Debug.Assert(configAsset != null);

        // Implementation...
    }

    /// <summary>
    /// Safely activates animation system with validation
    /// </summary>
    /// <param name="controller">VRMController instance</param>
    /// <param name="configAsset">Configuration asset to apply</param>
    /// <returns>
    /// Tuple containing success status and descriptive message
    /// </returns>
    public static async UniTask<(bool success, string message)> SafeActivateWithConfigAsset(
        this VRMController controller,
        VRMAnimationConfigAsset configAsset)
    {
        Debug.Assert(controller != null);
        Debug.Assert(configAsset != null);

        // Implementation...
    }
}
```

**Rationale**: Document the extended type in `<param name="this">` and explain added functionality. No Async suffix.

---

## 11. Interface vs Implementation (Critical!)

### Interface: Full Documentation
```csharp
/// <summary>
/// Interface dedicated to VTuber Animation control (ISP compliance)
/// </summary>
/// <remarks>
/// Interface for clients that only control animation playback.<br/>
/// State Query and Observable features are separated into distinct interfaces.
/// </remarks>
public interface IVTuberAnimationController
{
    /// <summary>
    /// Plays animation asynchronously
    /// </summary>
    /// <param name="animationPath">Animation path</param>
    /// <param name="wrapMode">Playback mode (Loop/Once/PingPong)</param>
    /// <returns>
    /// true: Playback start succeeded<br/>
    /// false: Playback start failed (Context not ready, invalid path, animation not found, etc.)
    /// </returns>
    /// <remarks>
    /// <strong>Preconditions:</strong><br/>
    /// - Context must be ready (IsReady = true)<br/>
    /// - animationPath must not be null and must be valid format
    /// </remarks>
    UniTask<bool> PlayAnimation(string animationPath, WrapMode wrapMode);
}
```

### Implementation: Use `<inheritdoc/>` (POCU)
```csharp
public partial class VRMController : IVTuberAnimationController
{
    private IAnimationSystem mCurrentSystem;
    private readonly Dictionary<string, Animation> mAnimations;

    /// <inheritdoc/>
    /// <remarks>
    /// <strong>Implementation:</strong> Path prefix-based auto-routing ("VRMA/" -> VRMAnimation, "State/{Layer}/{Identifier}" -> AnimatorController)<br/>
    /// <strong>Main Failures:</strong> Unknown prefix, System activation failure, invalid Layer/Identifier<br/>
    /// <strong>Note:</strong> wrapMode ignored when using AnimatorController
    /// </remarks>
    public async UniTask<bool> PlayAnimation(string animationPath, WrapMode wrapMode)
    {
        Debug.Assert(animationPath != null);

        // Implementation...
    }
}
```

### Anti-Pattern: Implementation Details in Interface
```csharp
// ❌ Bad: Too much implementation detail in interface
public interface IVTuberAnimationController
{
    /// <summary>Plays animation asynchronously</summary>
    /// <remarks>
    /// <strong>Smart Routing:</strong><br/>
    /// - "VRMA/" -> VRMAnimationSystem (UniVRM-based)<br/>
    /// - "State/" -> AnimatorControllerSystem (Mecanim)<br/>
    /// [... too many implementation details ...]
    /// </remarks>
    UniTask<bool> PlayAnimation(string animationPath, WrapMode wrapMode);
}
```

**3-Level Documentation Strategy:**

1. **Level 1 (Interface)**: API contract only - method purpose, parameter meanings, return semantics, generic preconditions
2. **Level 2/3 (Implementation)**: `/// <inheritdoc/>` + concise implementation-specific details with `<strong>` tags
3. **Conciseness**: Keep implementation remarks scannable, 1-3 bullet points recommended

---

## 12. Internal Implementation (POCU)

### Recommended Pattern
```csharp
public class ActionResult
{
    private Dictionary<string, object> mOutputData;
    private string mExceptionType;

    // Internal helper methods - camelCase per POCU
    private void initializeDefaults()
    {
        // Initialize default values
        Success = false;
        mOutputData = new Dictionary<string, object>();
    }

    // Complex internal logic - detailed explanation
    private bool validateActionType(string actionType)
    {
        // Action type validation logic:
        // 1. Check if not null or empty string
        // 2. Check if included in allowed type list
        // 3. Check if no special characters

        if (string.IsNullOrWhiteSpace(actionType))
        {
            return false;
        }

        // Additional validation...
        return true;
    }
}
```

**Rationale**: Internal code is for team members only. Use inline comments as needed, XML docs optional. Private methods use camelCase.

---

## Complete Example (POCU)

```csharp
namespace EventActionOrchestrator.Runtime.Core.Models
{
    /// <summary>
    /// Individual action execution result
    /// </summary>
    /// <remarks>
    /// Contains detailed result information after a single EventAction is executed.
    /// Included in the ActionResults list of EventActionResult.
    /// </remarks>
    [Serializable]
    public class ActionResult
    {
        private Dictionary<string, object> mOutputData;
        private string mExceptionType;
        private string mStackTrace;

        /// <summary>
        /// Indicates whether the action executed successfully
        /// </summary>
        public bool Success { get; set; }

        /// <summary>
        /// Indicates whether the action was skipped
        /// </summary>
        /// <remarks>
        /// Set to true when skipped due to unmet conditions.
        /// If true, the action was not executed regardless of Success value.
        /// </remarks>
        public bool Skipped { get; set; }

        /// <summary>
        /// Creates success result
        /// </summary>
        public static ActionResult CreateSuccess(
            string actionType,
            string messageOrNull = null,
            TimeSpan executionTime = default,
            Dictionary<string, object> outputDataOrNull = null)
        {
            Debug.Assert(actionType != null);

            ActionResult result = createResult(true, actionType, messageOrNull, executionTime);
            if (outputDataOrNull != null)
            {
                result.mOutputData = outputDataOrNull;
            }
            return result;
        }

        /// <summary>
        /// Creates skipped result
        /// </summary>
        /// <remarks>
        /// Skipping is not considered an error, so Success is set to true.
        /// </remarks>
        public static ActionResult CreateSkipped(string actionType, string reason)
        {
            Debug.Assert(actionType != null);
            Debug.Assert(reason != null);

            // Implementation...
        }

        private static ActionResult createResult(
            bool success, string actionType, string messageOrNull, TimeSpan executionTime)
        {
            // Implementation...
        }
    }
}
```
