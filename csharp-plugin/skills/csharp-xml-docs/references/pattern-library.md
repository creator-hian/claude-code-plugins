# Pattern Library

Complete examples for all common XML documentation scenarios.

## 1. Simple Properties and Fields

### ‚úÖ Recommended Pattern
```csharp
/// <summary>
/// Indicates whether the action executed successfully
/// </summary>
public bool Success { get; set; }

/// <summary>
/// Number of retry attempts
/// </summary>
public int RetryCount { get; set; }

/// <summary>
/// Priority level of the action
/// </summary>
public int Priority { get; set; }
```

### üá∞üá∑ Korean Example
```csharp
/// <summary>
/// Ïï°ÏÖò Ïã§Ìñâ ÏÑ±Í≥µ Ïó¨Î∂Ä
/// </summary>
public bool Success { get; set; }

/// <summary>
/// Ïû¨ÏãúÎèÑ ÌöüÏàò
/// </summary>
public int RetryCount { get; set; }

/// <summary>
/// Ïï°ÏÖò Ïö∞ÏÑ†ÏàúÏúÑ
/// </summary>
public int Priority { get; set; }
```

**Rationale**: Simple properties are self-explanatory. Use clear, concise language.

---

## 2. Complex Concepts (Use `<remarks>`)

### ‚úÖ Recommended Pattern
```csharp
/// <summary>
/// Indicates whether the action was skipped
/// </summary>
/// <remarks>
/// Set to true when skipped due to unmet conditions.
/// If true, the action was not executed regardless of Success value.
/// </remarks>
public bool Skipped { get; set; }

/// <summary>
/// Additional data generated by action execution
/// </summary>
/// <remarks>
/// Context information that can be utilized by other actions or systems.
/// </remarks>
public Dictionary<string, object> OutputData { get; set; }
```

### üá∞üá∑ Korean Example
```csharp
/// <summary>
/// Ïï°ÏÖòÏù¥ Í±¥ÎÑàÎõ∞Ïñ¥Ï°åÎäîÏßÄ Ïó¨Î∂Ä
/// </summary>
/// <remarks>
/// Ï°∞Í±¥Ïù¥ Ï∂©Ï°±ÎêòÏßÄ ÏïäÏïÑ Í±¥ÎÑàÎõ¥ Í≤ΩÏö∞ trueÎ°ú ÏÑ§Ï†ïÎê©ÎãàÎã§.
/// trueÏù∏ Í≤ΩÏö∞, Success Í∞íÍ≥º Í¥ÄÍ≥ÑÏóÜÏù¥ Ïï°ÏÖòÏù¥ Ïã§ÌñâÎêòÏßÄ ÏïäÏïòÏùåÏùÑ ÏùòÎØ∏Ìï©ÎãàÎã§.
/// </remarks>
public bool Skipped { get; set; }
```

### üåê Mixed Language Example
```csharp
/// <summary>
/// Ïï°ÏÖòÏù¥ Í±¥ÎÑàÎõ∞Ïñ¥Ï°åÎäîÏßÄ Ïó¨Î∂Ä
/// </summary>
/// <remarks>
/// <strong>Korean:</strong> Ï°∞Í±¥Ïù¥ Ï∂©Ï°±ÎêòÏßÄ ÏïäÏïÑ Í±¥ÎÑàÎõ¥ Í≤ΩÏö∞ trueÎ°ú ÏÑ§Ï†ïÎê©ÎãàÎã§.<br/>
/// <strong>English:</strong> Set to true when skipped due to unmet conditions.
/// </remarks>
public bool Skipped { get; set; }
```

---

## 3. Classes and Structs

### ‚úÖ Recommended Pattern
```csharp
/// <summary>
/// Individual action execution result
/// </summary>
/// <remarks>
/// Contains detailed result information after a single EventAction is executed.
/// Included in the ActionResults list of EventActionResult.
/// </remarks>
[Serializable]
public class ActionResult
{
    // Implementation...
}

/// <summary>
/// Type-safe identifier representing event type
/// </summary>
/// <remarks>
/// Prevents string-based errors in event type identification and provides
/// compile-time type safety for event routing.
/// </remarks>
public readonly struct EventType
{
    // Implementation...
}
```

**Rationale**: Classes and structs deserve both concise summary and detailed remarks.

---

## 4. Methods

### Simple Methods
```csharp
/// <summary>
/// Sets output data
/// </summary>
public void SetOutputData(string key, object value)
{
    OutputData ??= new Dictionary<string, object>();
    OutputData[key] = value;
}

/// <summary>
/// Checks whether action was actually executed
/// </summary>
public bool WasExecuted()
{
    return !Skipped;
}
```

### Complex Methods with Parameters
```csharp
/// <summary>
/// Retrieves output data
/// </summary>
/// <typeparam name="T">Data type to return</typeparam>
/// <param name="key">Key to retrieve</param>
/// <param name="defaultValue">Default value to return if key is not found</param>
/// <returns>Retrieved data or default value</returns>
public T GetOutputData<T>(string key, T defaultValue = default(T))
{
    if (OutputData == null || !OutputData.TryGetValue(key, out var value))
        return defaultValue;

    try
    {
        if (value is T directValue)
            return directValue;

        return (T)Convert.ChangeType(value, typeof(T));
    }
    catch
    {
        return defaultValue;
    }
}
```

### Multi-Step Processes (Use `<br/>`)
```csharp
/// <summary>
/// Executes event
/// </summary>
/// <param name="systemId">System ID</param>
/// <param name="eventId">Event ID</param>
/// <param name="contextData">Context data</param>
/// <returns>Event execution result</returns>
/// <remarks>
/// <para>
/// <strong>Execution Process:</strong><br/>
/// 1. Event definition lookup<br/>
/// 2. Event-level condition evaluation (performance optimization)<br/>
/// 3. Direct action list processing<br/>
/// 4. Execution time and metadata configuration
/// </para>
/// </remarks>
public async UniTask<EventActionResult> ExecuteEventAsync(
    string systemId,
    string eventId,
    object contextData = null)
{
    // Implementation...
}
```

### Feature Lists (Use `<br/>`)
```csharp
/// <summary>
/// Action execution engine
/// </summary>
/// <remarks>
/// <para>
/// <strong>Key Features:</strong><br/>
/// ‚Ä¢ Thread-safe action handler management<br/>
/// ‚Ä¢ Event definition caching and updates<br/>
/// ‚Ä¢ Condition-based action filtering<br/>
/// ‚Ä¢ Performance measurement and result aggregation
/// </para>
/// </remarks>
public class ActionExecutionEngine
{
    // Implementation...
}
```

---

## 5. Factory Methods

### ‚úÖ Recommended Pattern
```csharp
/// <summary>
/// Creates success result
/// </summary>
public static ActionResult CreateSuccess(
    string actionType,
    string message = null,
    TimeSpan executionTime = default,
    Dictionary<string, object> outputData = null)
{
    var result = new ActionResult(
        true,
        message ?? $"{actionType} action completed successfully.",
        actionType,
        executionTime
    );
    if (outputData != null)
    {
        result.OutputData = outputData;
    }
    return result;
}

/// <summary>
/// Creates failure result
/// </summary>
public static ActionResult CreateFailure(
    string actionType,
    string message,
    Exception exception = null,
    TimeSpan executionTime = default)
{
    var result = new ActionResult(
        false,
        message ?? $"{actionType} action failed.",
        actionType,
        executionTime
    );

    if (exception != null)
    {
        result.ExceptionType = exception.GetType().Name;
        result.StackTrace = exception.StackTrace;
        result.Message += $" Error: {exception.Message}";
    }

    return result;
}

/// <summary>
/// Creates skipped result
/// </summary>
/// <remarks>
/// Skipping is not considered an error, so Success is set to true.
/// </remarks>
public static ActionResult CreateSkipped(string actionType, string reason)
{
    return new ActionResult
    {
        Success = true,  // Skipping is not an error
        Skipped = true,
        ActionType = actionType ?? string.Empty,
        Message = $"{actionType} action skipped: {reason}",
        SkipReason = reason ?? "Unknown reason",
        ProcessedAt = DateTime.UtcNow,
    };
}
```

**Rationale**: Factory method names are self-documenting. Add remarks for special behaviors.

---

## 6. Constructors

### ‚úÖ Recommended Pattern
```csharp
/// <summary>
/// Default constructor
/// </summary>
public ActionResult()
{
    Success = false;
    Message = string.Empty;
    ActionType = string.Empty;
    ExecutionTime = TimeSpan.Zero;
    Skipped = false;
    SkipReason = string.Empty;
    OutputData = new Dictionary<string, object>();
    ExceptionType = string.Empty;
    StackTrace = string.Empty;
    ProcessedAt = DateTime.UtcNow;
    RetryCount = 0;
    Priority = 1;
}

/// <summary>
/// Parameterized constructor
/// </summary>
/// <param name="success">Success status</param>
/// <param name="message">Result message</param>
/// <param name="actionType">Action type</param>
/// <param name="executionTime">Execution time</param>
public ActionResult(
    bool success,
    string message,
    string actionType,
    TimeSpan executionTime = default)
{
    Success = success;
    Message = message ?? string.Empty;
    ActionType = actionType ?? string.Empty;
    ExecutionTime = executionTime;
    // ... other initializations
}
```

**Rationale**: Constructor parameters are typically self-explanatory from names and types.

---

## 7. Exception Documentation

### ‚úÖ Recommended Pattern
```csharp
/// <summary>
/// Loads VRM model from specified path
/// </summary>
/// <param name="path">Addressable path to VRM asset</param>
/// <returns>Loaded VRM instance</returns>
/// <exception cref="ArgumentNullException">Thrown when path is null</exception>
/// <exception cref="InvalidOperationException">Thrown when VRM context is not ready</exception>
/// <exception cref="System.IO.FileNotFoundException">Thrown when VRM asset is not found</exception>
public async UniTask<VrmInstance> LoadVRMAsync(string path)
{
    if (path == null)
        throw new ArgumentNullException(nameof(path));

    if (!IsReady)
        throw new InvalidOperationException("VRM context is not ready");

    // Implementation...
}
```

**Rationale**: Document exceptions that are part of the method's contract.

---

## 8. Property with Side Effects

### Use `<value>` Tag
```csharp
/// <summary>
/// Current animation mode
/// </summary>
/// <value>
/// Gets or sets the animation mode. Setting this value automatically switches
/// the underlying animation system. Returns null if no system is active.
/// </value>
public AnimationMode? CurrentMode
{
    get => _currentSystem?.Mode;
    set
    {
        if (value.HasValue)
            ActivateAnimationSystemAsync(value.Value).Forget();
    }
}
```

### Simple Properties (No `<value>` needed)
```csharp
/// <summary>
/// Indicates whether the VRM model is loaded
/// </summary>
public bool IsModelLoaded { get; private set; }

/// <summary>
/// Number of available animations
/// </summary>
public int AnimationCount => _animations?.Count ?? 0;
```

**Rationale**: Use `<value>` only when getter/setter have side effects or non-obvious behavior.

---

## 9. Enums

### ‚úÖ Recommended Pattern
```csharp
/// <summary>
/// Animation system mode
/// </summary>
public enum AnimationMode
{
    /// <summary>
    /// VRM Animation using VRMA files via UniVRM
    /// </summary>
    VRMAnimation,

    /// <summary>
    /// Unity Animator Controller using Mecanim
    /// </summary>
    AnimatorController,

    /// <summary>
    /// Hybrid mode supporting runtime switching between VRM and Animator
    /// </summary>
    Hybrid
}
```

### Bit Flags
```csharp
/// <summary>
/// Action execution options
/// </summary>
[Flags]
public enum ActionFlags
{
    /// <summary>No special options</summary>
    None = 0,

    /// <summary>Skip condition evaluation</summary>
    SkipConditions = 1 << 0,

    /// <summary>Continue execution even if action fails</summary>
    ContinueOnFailure = 1 << 1,

    /// <summary>Log detailed execution information</summary>
    VerboseLogging = 1 << 2
}
```

**Rationale**: Each enum value should have clear `<summary>` describing its purpose.

---

## 10. Extension Methods

### ‚úÖ Recommended Pattern
```csharp
/// <summary>
/// VRMController extension methods for animation configuration
/// </summary>
public static class VRMAnimationExtensions
{
    /// <summary>
    /// Activates animation system using ConfigAsset
    /// </summary>
    /// <param name="controller">VRMController instance</param>
    /// <param name="configAsset">Configuration asset to apply</param>
    /// <returns>
    /// true: Activation succeeded<br/>
    /// false: Activation failed
    /// </returns>
    public static async UniTask<bool> ActivateWithConfigAsset(
        this VRMController controller,
        VRMAnimationConfigAsset configAsset)
    {
        // Implementation...
    }

    /// <summary>
    /// Safely activates animation system with validation
    /// </summary>
    /// <param name="controller">VRMController instance</param>
    /// <param name="configAsset">Configuration asset to apply</param>
    /// <returns>
    /// Tuple containing success status and descriptive message
    /// </returns>
    public static async UniTask<(bool success, string message)> SafeActivateWithConfigAsset(
        this VRMController controller,
        VRMAnimationConfigAsset configAsset)
    {
        // Implementation...
    }
}
```

**Rationale**: Document the extended type in `<param name="this">` and explain added functionality.

---

## 11. Interface vs Implementation (Critical!)

### Interface: Full Documentation
```csharp
/// <summary>
/// Interface dedicated to VTuber Animation control (ISP compliance)
/// </summary>
/// <remarks>
/// Interface for clients that only control animation playback.<br/>
/// State Query and Observable features are separated into distinct interfaces.
/// </remarks>
public interface IVTuberAnimationController
{
    /// <summary>
    /// Plays animation asynchronously
    /// </summary>
    /// <param name="animationPath">Animation path</param>
    /// <param name="wrapMode">Playback mode (Loop/Once/PingPong)</param>
    /// <returns>
    /// true: Playback start succeeded<br/>
    /// false: Playback start failed (Context not ready, invalid path, animation not found, etc.)
    /// </returns>
    /// <remarks>
    /// <strong>Preconditions:</strong><br/>
    /// ‚Ä¢ Context must be ready (IsReady = true)<br/>
    /// ‚Ä¢ animationPath must not be null and must be valid format
    /// </remarks>
    UniTask<bool> PlayAnimationAsync(string animationPath, WrapMode wrapMode);
}
```

### Implementation: Use `<inheritdoc/>`
```csharp
public partial class VRMController : IVTuberAnimationController
{
    /// <inheritdoc/>
    /// <remarks>
    /// <strong>Implementation:</strong> Path prefix-based auto-routing ("VRMA/" ‚Üí VRMAnimation, "State/{Layer}/{Identifier}" ‚Üí AnimatorController)<br/>
    /// <strong>Main Failures:</strong> Unknown prefix, System activation failure, invalid Layer/Identifier<br/>
    /// <strong>Note:</strong> wrapMode ignored when using AnimatorController
    /// </remarks>
    public async UniTask<bool> PlayAnimationAsync(string animationPath, WrapMode wrapMode)
    {
        // Implementation...
    }
}
```

### ‚ùå Anti-Pattern: Implementation Details in Interface
```csharp
// ‚ùå Bad: Too much implementation detail in interface
public interface IVTuberAnimationController
{
    /// <summary>Plays animation asynchronously</summary>
    /// <remarks>
    /// <strong>Smart Routing:</strong><br/>
    /// ‚Ä¢ "VRMA/" ‚Üí VRMAnimationSystem (UniVRM-based)<br/>
    /// ‚Ä¢ "State/" ‚Üí AnimatorControllerSystem (Mecanim)<br/>
    /// [... too many implementation details ...]
    /// </remarks>
    UniTask<bool> PlayAnimationAsync(string animationPath, WrapMode wrapMode);
}
```

**3-Level Documentation Strategy:**

1. **Level 1 (Interface)**: API contract only - method purpose, parameter meanings, return semantics, generic preconditions
2. **Level 2/3 (Implementation)**: `/// <inheritdoc/>` + concise implementation-specific details with `<strong>` tags
3. **Conciseness**: Keep implementation remarks scannable, 1-3 bullet points recommended

---

## 12. Internal Implementation

### ‚úÖ Recommended Pattern
```csharp
// Internal helper methods - inline comments
private void InitializeDefaults()
{
    // Initialize default values
    Success = false;
    OutputData = new Dictionary<string, object>();
}

// Complex internal logic - detailed explanation
private bool ValidateActionType(string actionType)
{
    // Action type validation logic:
    // 1. Check if not null or empty string
    // 2. Check if included in allowed type list
    // 3. Check if no special characters

    if (string.IsNullOrWhiteSpace(actionType))
        return false;

    // Additional validation...
}
```

**Rationale**: Internal code is for team members only. Use inline comments as needed, XML docs optional.

---

## Complete Example

```csharp
namespace EventActionOrchestrator.Runtime.Core.Models
{
    /// <summary>
    /// Individual action execution result
    /// </summary>
    /// <remarks>
    /// Contains detailed result information after a single EventAction is executed.
    /// Included in the ActionResults list of EventActionResult.
    /// </remarks>
    [Serializable]
    public class ActionResult
    {
        /// <summary>
        /// Indicates whether the action executed successfully
        /// </summary>
        public bool Success { get; set; }

        /// <summary>
        /// Indicates whether the action was skipped
        /// </summary>
        /// <remarks>
        /// Set to true when skipped due to unmet conditions.
        /// If true, the action was not executed regardless of Success value.
        /// </remarks>
        public bool Skipped { get; set; }

        /// <summary>
        /// Creates success result
        /// </summary>
        public static ActionResult CreateSuccess(
            string actionType,
            string message = null,
            TimeSpan executionTime = default,
            Dictionary<string, object> outputData = null)
        {
            // Implementation...
        }

        /// <summary>
        /// Creates skipped result
        /// </summary>
        /// <remarks>
        /// Skipping is not considered an error, so Success is set to true.
        /// </remarks>
        public static ActionResult CreateSkipped(string actionType, string reason)
        {
            // Implementation...
        }
    }
}
```
